<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <title>Physical Sales Forecast Tool</title>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

  <style>
    :root {
      --bg-grad-start: #0f172a;
      --bg-grad-end: #020617;
      --card-glass: rgba(15, 23, 42, .7);
      --card-border: rgba(255, 255, 255, .08);
      --text-main: #f8fafc;
      --text-muted: #94a3b8;
      --accent-primary: #38bdf8;
      --accent-secondary: #818cf8;
      --accent-success: #2dd4bf;
      --accent-warning: #fbbf24;
      --accent-danger: #f43f5e;
      --input-bg: rgba(2, 6, 23, .45);
    }

    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "Segoe UI", Roboto, sans-serif;
      color: var(--text-main);
      margin: 0;
      min-height: 100vh;
      line-height: 1.5;
      background-color: var(--bg-grad-end);
      background-image: radial-gradient(circle at 50% 0%, var(--bg-grad-start), var(--bg-grad-end) 90%);
      -webkit-font-smoothing: antialiased;
    }

    .app {
      width: 100%;
      padding: 20px;
      max-width: 1200px;
      margin: 0 auto;
    }

    .header {
      margin-bottom: 18px;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 16px;
      flex-wrap: wrap;
    }

    .title {
      font-size: 28px;
      font-weight: 800;
      letter-spacing: -.02em;
      background: linear-gradient(135deg, #fff 0%, #94a3b8 100%);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .subtitle {
      font-size: 13px;
      color: var(--text-muted);
      margin-top: 4px;
    }

    .btn {
      background: rgba(56, 189, 248, .12);
      border: 1px solid rgba(56, 189, 248, .25);
      color: var(--text-main);
      padding: 10px 12px;
      border-radius: 12px;
      cursor: pointer;
      font-size: 12px;
      font-weight: 600;
      letter-spacing: .2px;
    }

    .btn:hover {
      filter: brightness(1.06)
    }

    .btn.secondary {
      background: rgba(129, 140, 248, .12);
      border-color: rgba(129, 140, 248, .25)
    }

    .btn.ghost {
      background: transparent;
      border-color: var(--card-border);
      color: var(--text-muted)
    }

    .btn.danger {
      background: rgba(244, 63, 94, .12);
      border-color: rgba(244, 63, 94, .25)
    }

    .grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 16px;
    }

    .card {
      background: var(--card-glass);
      backdrop-filter: blur(18px);
      border: 1px solid var(--card-border);
      border-radius: 20px;
      padding: 18px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, .2);
    }

    .card-title {
      font-size: 15px;
      font-weight: 700;
      margin: 0 0 12px 0;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .muted {
      color: var(--text-muted);
      font-size: 12px
    }

    .row {
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap
    }

    .field {
      display: flex;
      flex-direction: column;
      gap: 6px
    }

    label {
      font-size: 11px;
      color: var(--text-muted);
      letter-spacing: .4px;
      text-transform: uppercase
    }

    input[type="text"],
    input[type="number"],
    input[type="date"],
    select {
      background: var(--input-bg);
      border: 1px solid rgba(255, 255, 255, .10);
      color: var(--text-main);
      border-radius: 12px;
      padding: 10px 10px;
      font-size: 13px;
      outline: none;
    }

    input[type="number"] {
      text-align: right
    }

    input:focus {
      border-color: rgba(56, 189, 248, .5);
      box-shadow: 0 0 0 3px rgba(56, 189, 248, .08)
    }

    .table-wrap {
      overflow: auto;
      border-radius: 14px;
      border: 1px solid rgba(255, 255, 255, .07)
    }

    table {
      width: 100%;
      border-collapse: collapse;
      min-width: 720px
    }

    th,
    td {
      padding: 10px 10px;
      border-bottom: 1px solid rgba(255, 255, 255, .07);
      vertical-align: middle
    }

    th {
      font-size: 11px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: .45px;
      text-align: right;
      background: rgba(0, 0, 0, .18);
      position: sticky;
      top: 0;
      z-index: 2
    }

    th:first-child,
    td:first-child {
      text-align: left
    }

    td {
      font-size: 13px;
      text-align: right
    }

    .chip {
      display: inline-flex;
      gap: 8px;
      align-items: center;
      border: 1px solid rgba(255, 255, 255, .10);
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 12px;
      color: var(--text-muted);
      background: rgba(0, 0, 0, .12)
    }

    .pill {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 999px;
      font-size: 11px;
      border: 1px solid rgba(255, 255, 255, .10);
      color: var(--text-muted)
    }

    .pill.ok {
      border-color: rgba(45, 212, 191, .35);
      color: var(--accent-success)
    }

    .pill.warn {
      border-color: rgba(251, 191, 36, .35);
      color: var(--accent-warning)
    }

    .pill.bad {
      border-color: rgba(244, 63, 94, .35);
      color: var(--accent-danger)
    }

    details {
      border-radius: 18px;
      border: 1px solid rgba(255, 255, 255, .08);
      background: rgba(0, 0, 0, .10);
      padding: 12px
    }

    summary {
      cursor: pointer;
      list-style: none;
      font-weight: 700
    }

    summary::-webkit-details-marker {
      display: none
    }

    .score-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px
    }

    @media(min-width:900px) {
      .score-grid {
        grid-template-columns: repeat(4, minmax(0, 1fr));
      }
    }

    .score {
      padding: 12px;
      border-radius: 16px;
      border: 1px solid rgba(255, 255, 255, .08);
      background: rgba(0, 0, 0, .12)
    }

    .score .k {
      font-size: 11px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: .5px
    }

    .score .v {
      font-size: 18px;
      font-weight: 800;
      margin-top: 6px
    }

    .chart-container {
      height: 320px
    }

    .tiny {
      font-size: 11px;
      color: var(--text-muted)
    }

    .right {
      text-align: right
    }

    .actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: flex-end
    }

    .nowrap {
      white-space: nowrap
    }

    input::-webkit-outer-spin-button,
    input::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }

    input[type=number] {
      -moz-appearance: textfield;
      appearance: textfield;
    }

    /* Modal */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(2, 6, 23, 0.85);
      backdrop-filter: blur(8px);
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s;
    }

    .modal-overlay.active {
      opacity: 1;
      pointer-events: auto;
    }

    .modal-content {
      background: #1e293b;
      border: 1px solid var(--card-border);
      border-radius: 24px;
      max-width: 600px;
      width: 100%;
      max-height: 90vh;
      overflow-y: auto;
      padding: 32px;
      position: relative;
      box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
    }

    .close-modal {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(255, 255, 255, 0.1);
      border: none;
      color: #fff;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
    }

    .guide-step {
      margin-bottom: 24px;
    }

    .guide-step h3 {
      font-size: 14px;
      text-transform: uppercase;
      color: var(--accent-primary);
      margin-bottom: 8px;
      letter-spacing: 0.05em;
    }

    .guide-step p {
      font-size: 14px;
      color: #cbd5e1;
      margin-bottom: 8px;
    }

    .guide-step ul {
      padding-left: 20px;
      margin: 0;
    }

    .guide-step li {
      font-size: 13px;
      color: var(--text-muted);
      margin-bottom: 4px;
    }
  </style>
</head>

<body>
  <div class="app">
    <div class="header">
      <div>
        <div class="title">Physical Sales Forecast Tool</div>
        <div class="subtitle">Production → Allocation → Sales curve → Financial KPIs</div>
      </div>
      <div class="actions">
        <button class="btn ghost" id="btnGuide"
          style="border-radius:20px; padding:8px 16px; border-color:var(--accent-primary); color:var(--accent-primary);">GUIDE</button>
      </div>
    </div>

    <!-- Modal HTML -->
    <div id="guideModal" class="modal-overlay">
      <div class="modal-content">
        <button class="close-modal" id="btnCloseGuide">&times;</button>
        <h2 style="margin-top:0; margin-bottom:24px; font-size:24px;">How to Use</h2>

        <div class="guide-step">
          <h3>1. Production Costs</h3>
          <p>Define formats and manufacturing costs.</p>
          <ul>
            <li>Enter Format, Variant, Qty, and Unit Cost.</li>
            <li>Totals feed into the ROI calculation.</li>
          </ul>
        </div>

        <div class="guide-step">
          <h3>2. Allocation Strategy</h3>
          <p>Set pricing and distribute inventory.</p>
          <ul>
            <li><strong>SRP</strong>: Retail Price (D2C)</li>
            <li><strong>PPD</strong>: Wholesale Price (Distro/Tour)</li>
            <li>Allocate units to channels. Unallocated units show as red/yellow.</li>
          </ul>
        </div>

        <div class="guide-step">
          <h3>3. Sales Time Series</h3>
          <p>Forecast sales velocity.</p>
          <ul>
            <li>Set Announce and Street dates.</li>
            <li><strong>Sell-through %</strong>: Determines total units sold by horizon end.</li>
            <li>Default curves auto-distribute sales (Announce bump, Street peak, Decay).</li>
          </ul>
        </div>

        <div class="guide-step">
          <h3>4. Financials</h3>
          <p>Review profitability.</p>
          <ul>
            <li><strong>Cumulative KPI</strong>: Tracks Project Recoupment (Revenue / Total Sunken Cost).</li>
            <li><strong>Contribution</strong>: Net Profit after Mfg + Royalties.</li>
          </ul>
        </div>
      </div>
    </div>

    <div class="grid">

      <!-- 1) Manufacturing -->
      <section class="card">
        <div class="card-title">
          <span>1) Production Costs</span>
          <div class="row">
            <span class="chip"><span class="nowrap">Mech $/unit</span> <input id="mechRate" type="number" step="0.01"
                min="0" style="width:110px" /></span>
            <button class="btn" id="btnAddMfg">+ Add Format</button>
          </div>
        </div>
        <div class="muted" style="margin-bottom:10px">Define formats/variants you’re manufacturing. Totals feed the ROI
          / KPI math.</div>

        <div class="table-wrap">
          <table id="mfgTable">
            <thead>
              <tr>
                <th style="text-align:left">Format</th>
                <th style="text-align:left">Variant</th>
                <th>Mfg Qty</th>
                <th>Unit Cost</th>
                <th>Total Cost</th>
                <th style="text-align:center"> </th>
              </tr>
            </thead>
            <tbody></tbody>
            <tfoot>
              <tr>
                <td colspan="2" class="right"><span class="tiny">Totals</span></td>
                <td id="mfgTotalQty" class="nowrap"></td>
                <td></td>
                <td id="mfgTotalCost" class="nowrap"></td>
                <td></td>
              </tr>
            </tfoot>
          </table>
        </div>

        <div class="row" style="margin-top:12px;justify-content:space-between">
          <div class="row">
            <span class="pill">Fixed setup costs (optional)</span>
            <span class="chip">Lacquer <input id="lacquerCosts" type="number" step="1" min="0"
                style="width:110px" /></span>
            <span class="chip">Metalwork <input id="metalworkCosts" type="number" step="1" min="0"
                style="width:110px" /></span>
            <span class="chip">Plating <input id="platingCosts" type="number" step="1" min="0"
                style="width:110px" /></span>
            <span class="chip">Other <input id="otherSetupCosts" type="number" step="1" min="0"
                style="width:110px" /></span>
          </div>
          <div class="tiny">Tip: use TAB / Shift+TAB to move across cells.</div>
        </div>
      </section>

      <!-- 2) Allocation -->
      <section class="card">
        <div class="card-title">
          <span>2) Allocation Strategy</span>
          <span class="pill">PPD = wholesale • SRP = D2C</span>
        </div>
        <div class="muted" style="margin-bottom:10px">
          For each product: set SRP/PPD and allocate units into channels. D2C fulfillment sells at SRP; tour sells at
          PPD.
        </div>

        <div class="table-wrap">
          <table id="allocTable">
            <thead>
              <tr>
                <th style="text-align:left;min-width:240px">Product</th>
                <th>SRP</th>
                <th>PPD</th>
                <th>Unallocated</th>
                <th>Amped</th>
                <th>Integral UK</th>
                <th>Integral EU</th>
                <th>ShipRec (D2C)</th>
                <th>ShipRec (Tour)</th>
                <th>Ochre (D2C)</th>
                <th>Ochre (Tour)</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </section>

      <!-- 3) Sales Matrix -->
      <section class="card">
        <div class="card-title">
          <span>3) Sales Time Series</span>
          <span class="pill">Drives unit sell-through over time</span>
        </div>

        <div class="row" style="justify-content:space-between;margin-bottom:10px">
          <div class="row">
            <div class="field">
              <label>Announce date</label>
              <input id="announceDate" type="date" />
            </div>
            <div class="field">
              <label>Street date</label>
              <input id="streetDate" type="date" />
            </div>
            <div class="field">
              <label>Horizon (months)</label>
              <input id="horizonMonths" type="number" min="1" max="36" step="1" style="width:120px" />
            </div>
            <div class="field">
              <label>Sell-through by end (%)</label>
              <input id="sellThroughTarget" type="number" min="0" max="100" step="1" style="width:160px" />
            </div>
          </div>
          <div class="row">
            <label style="text-transform:none;letter-spacing:0">Use default curves</label>
            <input id="useDefaultCurves" type="checkbox" checked />
            <button class="btn ghost" id="btnResetCurves">Reset curves</button>
          </div>
        </div>

        <details id="advAssumptions">
          <summary>Advanced Assumptions (edit curves)</summary>
          <div class="muted" style="margin:10px 0 12px">
            Uncheck “Use default curves” to edit monthly % per row. Percentages should sum to your Sell-through target.
          </div>
          <div class="row" style="justify-content:space-between;margin-bottom:10px">
            <div class="row">
              <span class="chip">Copy curve from
                <select id="copyFrom"></select>
              </span>
              <span class="chip">to
                <select id="copyTo"></select>
              </span>
              <button class="btn" id="btnCopyCurve">Copy</button>
            </div>
            <div class="tiny">Rounding: floors each month, then puts remainder into Street month.</div>
          </div>

          <div class="table-wrap">
            <table id="matrixTable">
              <thead></thead>
              <tbody></tbody>
            </table>
          </div>
        </details>
      </section>

      <!-- 4) Financials -->
      <section class="card">
        <div class="card-title">
          <span>4) Financial Performance</span>
          <span class="pill">KPI = Gross Revenue / Cost</span>
        </div>

        <div class="score-grid" id="scorecards"></div>

        <div style="margin-top:14px">
          <div class="muted" style="margin-bottom:8px">Monthly revenue (bars) + cumulative KPI (line)</div>
          <div class="chart-container"><canvas id="revChart"></canvas></div>
        </div>

        <div style="margin-top:14px" class="table-wrap">
          <table id="formatBreakdown">
            <thead>
              <tr>
                <th style="text-align:left;min-width:220px">Format Variant</th>
                <th>Units Sold</th>
                <th>Revenue</th>
                <th>Mfg Cost</th>
                <th>Royalties</th>
                <th>Contribution</th>
                <th style="text-align:center">KPI</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>

      </section>



    </div>
  </div>

  <script>
    (() => {
      // -------------------------
      // Data model
      // -------------------------
      const CHANNELS = [
        { key: 'amped', name: 'Amped', price: 'PPD' },
        { key: 'intUK', name: 'Integral UK', price: 'PPD' },
        { key: 'intEU', name: 'Integral EU', price: 'PPD' },
        { key: 'shipRecD2C', name: 'ShipRec (D2C)', price: 'SRP' },
        { key: 'shipRecTour', name: 'ShipRec (Tour)', price: 'PPD' },
        { key: 'ochreD2C', name: 'Ochre (D2C)', price: 'SRP' },
        { key: 'ochreTour', name: 'Ochre (Tour)', price: 'PPD' },
      ];

      // Defaults
      let state = {
        global: {
          mechanicalStatRate: 1.27,
          lacquerCosts: 0,
          metalworkCosts: 0,
          platingCosts: 0,
          otherSetupCosts: 0,
        },
        dates: {
          announceDate: null,
          streetDate: null,
          horizonMonths: 12,
          sellThroughTargetPct: 100,
          useDefaultCurves: true,
        },
        mfg: [
          { format: 'LP', variant: 'Standard Black', qty: 2000, cost: 4.50 },
          { format: 'LP', variant: 'Gold Vinyl D2C', qty: 500, cost: 5.00 },
          { format: 'CD', variant: 'Jewel Case', qty: 1000, cost: 2.00 },
        ],
        alloc: [
          // one per product
          // { srp:25, ppd:12, amped:0, ... }
        ],
        matrix: [
          // built from alloc; each row per product x channel
          // { id, productIndex, channelKey, label, allocUnits, price, unitCost, curve:[pct...] }
        ]
      };

      // -------------------------
      // Helpers
      // -------------------------
      const $ = (s) => document.querySelector(s);

      function money(n) {
        if (!isFinite(n)) return '--';
        return '$' + n.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
      }
      function num(n) {
        if (!isFinite(n)) return '--';
        return n.toLocaleString();
      }
      function clamp(n, lo, hi) {
        n = Number(n);
        if (!isFinite(n)) return lo;
        return Math.min(hi, Math.max(lo, n));
      }
      function monthStart(d) {
        return new Date(d.getFullYear(), d.getMonth(), 1);
      }
      function fmtMonth(d) {
        return d.toLocaleDateString('en-US', { month: 'short', year: '2-digit' });
      }
      function stableId(productIndex, channelKey) {
        return `p${productIndex}__${channelKey}`;
      }

      function defaultDatesInit() {
        const now = new Date();
        // announce = first of current month
        const announce = new Date(now.getFullYear(), now.getMonth(), 1);
        const street = new Date(now);
        street.setMonth(street.getMonth() + 2);
        state.dates.announceDate ||= announce.toISOString().slice(0, 10);
        state.dates.streetDate ||= street.toISOString().slice(0, 10);
      }

      // Default curve weights: announce bump, street peak, decay. Normalized to sum=1 then multiplied by sellThroughTarget.
      function generateDefaultCurve(streetIndex, horizonMonths, sellThroughTarget) {
        const weights = new Array(horizonMonths).fill(0);
        // announce bump
        if (streetIndex > 0) {
          weights[0] = 0.15;
          for (let k = 1; k < streetIndex; k++) weights[k] = 0.02;
        }
        if (streetIndex >= 0 && streetIndex < horizonMonths) {
          weights[streetIndex] = 0.50;
          let decay = 0.15;
          for (let k = streetIndex + 1; k < horizonMonths; k++) {
            weights[k] = decay;
            decay *= 0.6;
          }
        } else {
          weights[0] = 1.0;
        }
        const sum = weights.reduce((a, b) => a + b, 0) || 1;
        const norm = weights.map(w => w / sum);
        return norm.map(w => w * sellThroughTarget);
      }

      // Unit rounding rule: floor each month then add remainder to street month (or last nonzero)
      function unitsByMonthFromPct(allocation, curve, streetIdx) {
        const raw = curve.map(p => allocation * p);
        const floored = raw.map(x => Math.floor(x));
        let used = floored.reduce((a, b) => a + b, 0);

        // Calculate the INTENDED total units based on the curve's sum
        // (Curve already sums to sell-through %, e.g., 0.85)
        const curveSum = curve.reduce((a, b) => a + b, 0);
        const targetUnits = Math.floor(allocation * curveSum);

        let remainder = targetUnits - used;

        if (remainder <= 0) return floored;
        let idx = streetIdx;
        if (idx < 0 || idx >= floored.length) {
          idx = floored.length - 1;
          for (let i = floored.length - 1; i >= 0; i--) {
            if (floored[i] > 0) { idx = i; break; }
          }
        }
        floored[idx] += remainder;
        return floored;
      }

      function totalMfgCost() {
        return state.mfg.reduce((s, r) => s + (Number(r.qty) || 0) * (Number(r.cost) || 0), 0);
      }
      function totalMfgQty() {
        return state.mfg.reduce((s, r) => s + (Number(r.qty) || 0), 0);
      }
      function totalFixedCosts() {
        const g = state.global;
        return (Number(g.lacquerCosts) || 0) + (Number(g.metalworkCosts) || 0) + (Number(g.platingCosts) || 0) + (Number(g.otherSetupCosts) || 0);
      }

      function ensureAllocLength() {
        if (state.alloc.length === state.mfg.length) return;
        const next = [];
        for (let i = 0; i < state.mfg.length; i++) {
          const prev = state.alloc[i];
          next.push(prev || { srp: 25, ppd: 12, amped: 0, intUK: 0, intEU: 0, shipRecD2C: 0, shipRecTour: 0, ochreD2C: 0, ochreTour: 0 });
        }
        state.alloc = next;
      }

      function productLabel(i) {
        const p = state.mfg[i];
        return `${p.variant || ''} ${p.format || ''}`.trim() || `Product ${i + 1}`;
      }

      function getBuckets() {
        const announce = new Date(state.dates.announceDate + 'T00:00:00');
        const street = new Date(state.dates.streetDate + 'T00:00:00');
        const horizon = clamp(state.dates.horizonMonths, 1, 36);
        const buckets = [];
        const start = monthStart(announce);
        for (let i = 0; i < horizon; i++) {
          const d = new Date(start);
          d.setMonth(d.getMonth() + i);
          buckets.push({
            index: i, date: d, label: fmtMonth(d),
            isStreet: (d.getFullYear() === street.getFullYear() && d.getMonth() === street.getMonth())
          });
        }
        const streetIndex = buckets.findIndex(b => b.isStreet);
        return { buckets, streetIndex };
      }

      // -------------------------
      // Rendering: Manufacturing
      // -------------------------
      function renderMfg() {
        const tbody = $('#mfgTable tbody');
        // Only rebuild if row count mismatch
        if (tbody.children.length !== state.mfg.length) {
          tbody.innerHTML = '';
          state.mfg.forEach((r, i) => {
            const tr = document.createElement('tr');
            tr.innerHTML = `
            <td><input type="text" data-mfg="${i}" data-field="format" style="width:90px;text-align:left"/></td>
            <td><input type="text" data-mfg="${i}" data-field="variant" style="width:220px;text-align:left"/></td>
            <td><input type="number" min="0" step="1" data-mfg="${i}" data-field="qty" style="width:110px"/></td>
            <td><input type="number" min="0" step="0.01" data-mfg="${i}" data-field="cost" style="width:110px"/></td>
            <td class="nowrap row-total"></td>
            <td style="text-align:center"><button class="btn danger" data-remove-mfg="${i}" style="padding:6px 10px;font-size:11px">Remove</button></td>
          `;
            tbody.appendChild(tr);
          });
        }

        let tq = 0, tc = 0;
        state.mfg.forEach((r, i) => {
          const qty = Number(r.qty) || 0;
          const cost = Number(r.cost) || 0;
          const rowTotal = qty * cost;
          tq += qty; tc += rowTotal;

          const tr = tbody.children[i];
          if (!tr) return;
          // Update values without destroying focus
          const inputs = tr.querySelectorAll('input');
          const fmt = inputs[0], vnt = inputs[1], q = inputs[2], c = inputs[3];

          if (document.activeElement !== fmt) fmt.value = r.format;
          if (document.activeElement !== vnt) vnt.value = r.variant;
          if (document.activeElement !== q) q.value = qty;
          if (document.activeElement !== c) c.value = cost;

          tr.querySelector('.row-total').textContent = money(rowTotal);
          // Update data attributes just in case index shifted (which requires rebuild usually, but good practice)
          inputs.forEach(inp => inp.setAttribute('data-mfg', i));
          tr.querySelector('button').setAttribute('data-remove-mfg', i);
        });

        $('#mfgTotalQty').textContent = num(tq);
        $('#mfgTotalCost').textContent = money(tc);
      }

      // -------------------------
      // Rendering: Allocation
      // -------------------------
      function renderAlloc() {
        ensureAllocLength();
        const tbody = $('#allocTable tbody');

        if (tbody.children.length !== state.mfg.length) {
          tbody.innerHTML = '';
          state.mfg.forEach((p, i) => {
            const tr = document.createElement('tr');
            // Build input columns
            const channelsHtml = CHANNELS.map(c => `
              <td><input type="number" min="0" step="1" data-alloc="${i}" data-field="${c.key}" style="width:90px"/></td>
            `).join('');

            tr.innerHTML = `
            <td style="text-align:left">
              <div class="prod-label" style="font-weight:700"></div>
              <div class="prod-sub tiny"></div>
            </td>
            <td><input type="number" min="0" step="0.5" data-alloc="${i}" data-field="srp" style="width:90px"/></td>
            <td><input type="number" min="0" step="0.5" data-alloc="${i}" data-field="ppd" style="width:90px"/></td>
            <td><span class="pill unalloc-pill"></span></td>
            ${channelsHtml}
          `;
            tbody.appendChild(tr);
          });
        }

        state.mfg.forEach((p, i) => {
          const tr = tbody.children[i];
          if (!tr) return;
          const a = state.alloc[i];
          const allocSum = CHANNELS.reduce((s, c) => s + (Number(a[c.key]) || 0), 0);
          const unalloc = (Number(p.qty) || 0) - allocSum;
          const unallocClass = unalloc === 0 ? 'ok' : (unalloc < 0 ? 'bad' : 'warn');

          // Update Labels
          tr.querySelector('.prod-label').textContent = productLabel(i);
          tr.querySelector('.prod-sub').textContent = `${(Number(p.qty) || 0).toLocaleString()} units manufactured`;

          // Update Inputs (SRP, PPD)
          const inputs = tr.querySelectorAll('input');
          // inputs[0]=SRP, [1]=PPD, [2..]=Channels
          const srp = inputs[0];
          const ppd = inputs[1];
          // Check active check
          if (document.activeElement !== srp) srp.value = Number(a.srp) || 0;
          if (document.activeElement !== ppd) ppd.value = Number(a.ppd) || 0;

          // Update Unalloc Pill
          const pill = tr.querySelector('.unalloc-pill');
          pill.className = `pill unalloc-pill ${unallocClass}`;
          pill.textContent = unalloc.toLocaleString();

          // Update Channel Inputs
          CHANNELS.forEach((c, idx) => {
            const inp = inputs[2 + idx];
            if (document.activeElement !== inp) inp.value = Number(a[c.key]) || 0;
          });
        });
      }

      // -------------------------
      // Matrix build + rendering
      // -------------------------
      function buildMatrix(preserveCurves = true) {
        ensureAllocLength();
        const { buckets, streetIndex } = getBuckets();
        const horizon = buckets.length;
        const sellThrough = clamp(state.dates.sellThroughTargetPct, 0, 100) / 100;

        const old = new Map(state.matrix.map(r => [r.id, r]));
        const next = [];

        state.mfg.forEach((p, productIndex) => {
          const a = state.alloc[productIndex];
          CHANNELS.forEach(ch => {
            const allocUnits = Number(a[ch.key]) || 0;
            if (allocUnits <= 0) return;

            const id = stableId(productIndex, ch.key);
            const existing = old.get(id);

            const price = (ch.price === 'SRP' ? Number(a.srp) || 0 : Number(a.ppd) || 0);
            const unitCost = Number(p.cost) || 0;

            let curve;
            if (preserveCurves && existing && Array.isArray(existing.curve) && existing.curve.length === horizon) {
              curve = existing.curve.slice();
            } else {
              curve = generateDefaultCurve(streetIndex, horizon, sellThrough);
            }

            next.push({
              id, productIndex, channelKey: ch.key,
              label: `${productLabel(productIndex)} • ${ch.name}`,
              allocUnits,
              price,
              unitCost,
              curve
            });
          });
        });

        state.matrix = next;
        return { buckets, streetIndex };
      }

      function renderMatrix(buckets) {
        const thead = $('#matrixTable thead');
        const tbody = $('#matrixTable tbody');

        // Header
        const headRow = document.createElement('tr');
        headRow.innerHTML = `
      <th style="text-align:left;min-width:280px">Channel / Product</th>
      <th>Alloc</th>
      <th>Price</th>
      <th>Cost</th>
      ${buckets.map(b => `<th class="nowrap" style="${b.isStreet ? 'color:var(--accent-warning);' : ''}">${b.label}</th>`).join('')}
      <th>Sum %</th>
    `;
        thead.innerHTML = '';
        thead.appendChild(headRow);

        // Body
        tbody.innerHTML = '';
        const editable = !state.dates.useDefaultCurves;

        state.matrix.forEach((r, idx) => {
          const tr = document.createElement('tr');
          const sumPct = r.curve.reduce((a, b) => a + b, 0);

          tr.innerHTML = `
        <td style="text-align:left">
          <div style="font-weight:700">${escapeHtml(r.label)}</div>
          <div class="tiny">${r.channelKey.toUpperCase()} • price ${money(r.price)} • alloc ${r.allocUnits.toLocaleString()}</div>
        </td>
        <td>${r.allocUnits.toLocaleString()}</td>
        <td><input type="number" min="0" step="0.5" value="${r.price}" data-matrix="${r.id}" data-field="price" style="width:90px" ${editable ? '' : 'disabled'}/></td>
        <td><input type="number" min="0" step="0.01" value="${r.unitCost}" data-matrix="${r.id}" data-field="unitCost" style="width:90px" ${editable ? '' : 'disabled'}/></td>
        ${r.curve.map((p, m) => `
          <td>
            <input type="number" min="0" step="0.1" value="${(p * 100).toFixed(1)}" data-matrix="${r.id}" data-field="pct" data-month="${m}" style="width:86px" ${editable ? '' : 'disabled'}/>
          </td>
        `).join('')}
        <td class="nowrap">${(sumPct * 100).toFixed(1)}%</td>
      `;
          tbody.appendChild(tr);
        });

        // Copy dropdowns
        const opts = state.matrix.map(r => `<option value="${r.id}">${escapeHtml(r.label)}</option>`).join('');
        $('#copyFrom').innerHTML = opts;
        $('#copyTo').innerHTML = opts;
      }

      // -------------------------
      // Financial calculations + rendering
      // -------------------------
      let chart = null;

      function computeFinancials(buckets, streetIndex) {
        const mech = Number(state.global.mechanicalStatRate) || 0;
        const fixed = totalFixedCosts();
        const mfgCostTotal = totalMfgCost();

        // month totals
        const monthRevenue = new Array(buckets.length).fill(0);
        const monthCost = new Array(buckets.length).fill(0); // manufacturing + royalties allocated by units sold (mfg cost assumes per unit cost)
        const monthUnits = new Array(buckets.length).fill(0);

        // per format breakdown
        const perProduct = state.mfg.map(() => ({
          units: 0, revenue: 0, mfgCost: 0, royalties: 0, contribution: 0
        }));

        state.matrix.forEach(r => {
          const unitsByMonth = unitsByMonthFromPct(r.allocUnits, r.curve, streetIndex);
          unitsByMonth.forEach((u, mi) => {
            const rev = u * (Number(r.price) || 0);
            const mfg = u * (Number(r.unitCost) || 0);
            const roy = u * mech;
            monthRevenue[mi] += rev;
            monthCost[mi] += (mfg + roy);
            monthUnits[mi] += u;
            const pIdx = r.productIndex;
            perProduct[pIdx].units += u;
            perProduct[pIdx].revenue += rev;
            // perProduct[pIdx].mfgCost += mfg; // REMOVE: Don't use marginal cost
            perProduct[pIdx].royalties += roy;
          });
        });

        // Calculate Cost per Product based on TOTAL Manufacturing (Sunken Cost)
        perProduct.forEach((p, i) => {
          const mfgRun = state.mfg[i];
          // Full cost of the run
          const fullRunCost = (Number(mfgRun.qty) || 0) * (Number(mfgRun.cost) || 0);
          p.mfgCost = fullRunCost;

          p.contribution = p.revenue - p.mfgCost - p.royalties;
        });

        const grossRevenue = monthRevenue.reduce((a, b) => a + b, 0);
        const varCost = monthCost.reduce((a, b) => a + b, 0);
        const totalCost = mfgCostTotal + fixed + (perProduct.reduce((a, p) => a + p.royalties, 0)); // use full manufactured cost + royalties (even unsold units not costed again)
        // NOTE: KPI requested = Gross Revenue / Cost, and user specifically wants "Total Production Cost from top table used there".
        // We'll define "Cost" for KPI as: (total manufacturing cost + fixed setup + royalties on sold units).
        const kpi = totalCost > 0 ? grossRevenue / totalCost : 0;
        const contribution = grossRevenue - totalCost;
        const roi = totalCost > 0 ? grossRevenue / totalCost : 0;

        // Monthly KPI series (cumulative)
        // Monthly KPI series (cumulative)
        const cumRevenue = [];
        const cumKpi = [];
        let rSum = 0;
        let roySum = 0;

        // Base cost for recoupment = Full Manufacturing Run + Fixed Costs
        // This means at month 0 (before sales), you are at 0 revenue / High Cost
        const baseRecoupCost = mfgCostTotal + fixed;

        for (let i = 0; i < buckets.length; i++) {
          rSum += monthRevenue[i];

          // Royalties are incurred per sale, so they accumulate
          // We must extract royalties from the monthUnits to be precise, 
          // or just re-sum from the loop above if we tracked it.
          // Let's re-calculate royalties for this month from the units:
          const mRoy = monthUnits[i] * mech;
          roySum += mRoy;

          const totalCostToDate = baseRecoupCost + roySum;

          cumRevenue.push(rSum);
          cumKpi.push(totalCostToDate > 0 ? rSum / totalCostToDate : 0);
        }

        return {
          grossRevenue, totalCost, contribution, kpi, roi,
          monthRevenue, monthUnits, cumKpi,
          perProduct
        };
      }

      function renderScorecards(fin) {
        const el = $('#scorecards');
        const fixed = totalFixedCosts();
        const mfgCost = totalMfgCost();
        const roy = fin.perProduct.reduce((a, p) => a + p.royalties, 0);

        el.innerHTML = `
      <div class="score"><div class="k">Manufactured Units</div><div class="v">${num(totalMfgQty())}</div></div>
      <div class="score"><div class="k">Gross Revenue</div><div class="v">${money(fin.grossRevenue)}</div></div>
      <div class="score"><div class="k">Total Cost</div><div class="v">${money(fin.totalCost)}</div><div class="tiny">Mfg ${money(mfgCost)} + Fixed ${money(fixed)} + Roy ${money(roy)}</div></div>
      <div class="score"><div class="k">KPI (Rev / Cost)</div><div class="v" style="color:var(--accent-success)">${(fin.kpi || 0).toFixed(2)}x</div></div>
      <div class="score"><div class="k">Net Contribution</div><div class="v">${money(fin.contribution)}</div></div>
      <div class="score"><div class="k">Units Sold</div><div class="v">${num(fin.monthUnits.reduce((a, b) => a + b, 0))}</div></div>
      <div class="score"><div class="k">Sell-through</div><div class="v">${(totalMfgQty() > 0 ? (fin.monthUnits.reduce((a, b) => a + b, 0) / totalMfgQty() * 100) : 0).toFixed(1)}%</div></div>
      <div class="score"><div class="k">Horizon</div><div class="v">${clamp(state.dates.horizonMonths, 1, 36)} mo</div></div>
    `;
      }

      function renderFormatBreakdown(fin) {
        const tbody = $('#formatBreakdown tbody');
        tbody.innerHTML = '';
        fin.perProduct.forEach((p, i) => {
          const label = productLabel(i);
          const fixed = 0; // not allocated per format here
          const cost = p.mfgCost + p.royalties + fixed;
          const kpi = cost > 0 ? p.revenue / cost : 0;
          const tr = document.createElement('tr');
          tr.innerHTML = `
        <td style="text-align:left">
          <div style="font-weight:700">${escapeHtml(label)}</div>
          <div class="tiny">${state.mfg[i].qty.toLocaleString()} mfg • unit cost ${money(state.mfg[i].cost)}</div>
        </td>
        <td>${p.units.toLocaleString()}</td>
        <td>${money(p.revenue)}</td>
        <td>${money(p.mfgCost)}</td>
        <td>${money(p.royalties)}</td>
        <td>${money(p.contribution - fixed)}</td>
        <td style="text-align:center">${kpi.toFixed(2)}x</td>
      `;
          tbody.appendChild(tr);
        });
      }

      function renderChart(buckets, fin) {
        const ctx = $('#revChart').getContext('2d');
        const labels = buckets.map(b => b.label);
        if (chart) chart.destroy();
        chart = new Chart(ctx, {
          type: 'bar',
          data: {
            labels,
            datasets: [
              { label: 'Monthly Revenue', data: fin.monthRevenue, yAxisID: 'y' },
              { type: 'line', label: 'Cumulative KPI', data: fin.cumKpi, yAxisID: 'y1', tension: 0.25, pointRadius: 0 }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { labels: { color: '#cbd5e1' } },
              tooltip: {
                callbacks: {
                  label: (ctx) => {
                    if (ctx.dataset.type === 'line') return ` ${ctx.dataset.label}: ${(ctx.parsed.y || 0).toFixed(2)}x`;
                    return ` ${ctx.dataset.label}: ${money(ctx.parsed.y || 0)}`;
                  }
                }
              }
            },
            scales: {
              x: { ticks: { color: '#94a3b8' }, grid: { color: 'rgba(255,255,255,.05)' } },
              y: { ticks: { color: '#94a3b8' }, grid: { color: 'rgba(255,255,255,.05)' } },
              y1: {
                position: 'right',
                ticks: { color: '#fbbf24', callback: (v) => `${Number(v).toFixed(2)}x` },
                grid: { drawOnChartArea: false }
              }
            }
          }
        });
      }

      function escapeHtml(s) {
        return String(s ?? '').replace(/[&<>"']/g, (c) => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[c]));
      }

      // -------------------------
      // Recalc pipeline (single source of truth)
      // -------------------------
      function recalc({ preserveCurves = true } = {}) {
        // sync global controls
        state.global.mechanicalStatRate = Number($('#mechRate').value) || 0;
        state.global.lacquerCosts = Number($('#lacquerCosts').value) || 0;
        state.global.metalworkCosts = Number($('#metalworkCosts').value) || 0;
        state.global.platingCosts = Number($('#platingCosts').value) || 0;
        state.global.otherSetupCosts = Number($('#otherSetupCosts').value) || 0;

        state.dates.announceDate = $('#announceDate').value;
        state.dates.streetDate = $('#streetDate').value;
        state.dates.horizonMonths = clamp($('#horizonMonths').value, 1, 36);
        state.dates.sellThroughTargetPct = clamp($('#sellThroughTarget').value, 0, 100);
        state.dates.useDefaultCurves = $('#useDefaultCurves').checked;

        renderMfg();
        renderAlloc();

        const { buckets, streetIndex } = buildMatrix(preserveCurves);
        renderMatrix(buckets);

        const fin = computeFinancials(buckets, streetIndex);
        renderScorecards(fin);
        renderFormatBreakdown(fin);
        renderChart(buckets, fin);
      }

      // -------------------------
      // Event wiring
      // -------------------------
      function wire() {
        // Global controls
        // Special handling for sellThroughTarget to force curve rebuild
        $('#sellThroughTarget').addEventListener('change', () => recalc({ preserveCurves: false }));

        ['mechRate', 'lacquerCosts', 'metalworkCosts', 'platingCosts', 'otherSetupCosts',
          'announceDate', 'streetDate', 'horizonMonths', 'useDefaultCurves'
        ].forEach(id => {
          const el = $('#' + id);
          if (el) {
            el.addEventListener('input', () => recalc({ preserveCurves: true }));
            el.addEventListener('change', () => recalc({ preserveCurves: true }));
          }
        });

        // Guide Modal
        const modal = $('#guideModal');
        const openBtn = $('#btnGuide');
        const closeBtn = $('#btnCloseGuide');

        const toggleModal = (show) => modal.classList.toggle('active', show);

        openBtn.addEventListener('click', () => toggleModal(true));
        closeBtn.addEventListener('click', () => toggleModal(false));

        // ESC key
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape') toggleModal(false);
        });

        // Click outside
        modal.addEventListener('click', (e) => {
          if (e.target === modal) toggleModal(false);
        });

        // Manufacturing table delegation
        $('#mfgTable').addEventListener('change', (e) => {
          const el = e.target;
          const idx = el.getAttribute('data-mfg');
          const field = el.getAttribute('data-field');
          if (idx === null || !field) return;
          const i = Number(idx);
          if (!state.mfg[i]) return;
          if (field === 'qty') state.mfg[i][field] = Math.max(0, Math.floor(Number(el.value) || 0));
          else if (field === 'cost') state.mfg[i][field] = Math.max(0, Number(el.value) || 0);
          else state.mfg[i][field] = el.value;
          ensureAllocLength();
          recalc({ preserveCurves: true });
        });
        $('#mfgTable').addEventListener('click', (e) => {
          const btn = e.target.closest('[data-remove-mfg]');
          if (!btn) return;
          const i = Number(btn.getAttribute('data-remove-mfg'));
          state.mfg.splice(i, 1);
          state.alloc.splice(i, 1);
          recalc({ preserveCurves: false });
        });

        $('#btnAddMfg').addEventListener('click', () => {
          state.mfg.push({ format: 'LP', variant: '', qty: 0, cost: 0 });
          ensureAllocLength();
          recalc({ preserveCurves: false });
        });

        // Allocation table delegation
        $('#allocTable').addEventListener('change', (e) => {
          const el = e.target;
          const idx = el.getAttribute('data-alloc');
          const field = el.getAttribute('data-field');
          if (idx === null || !field) return;
          const i = Number(idx);
          if (!state.alloc[i]) return;

          if (field === 'srp' || field === 'ppd') {
            state.alloc[i][field] = Math.max(0, Number(el.value) || 0);
          } else {
            state.alloc[i][field] = Math.max(0, Math.floor(Number(el.value) || 0));
          }

          // prevent over-allocation? allow but highlight unallocated; just clamp negatives already
          recalc({ preserveCurves: true });
        });

        // Matrix edits
        $('#matrixTable').addEventListener('change', (e) => {
          const el = e.target;
          const id = el.getAttribute('data-matrix');
          const field = el.getAttribute('data-field');
          if (!id || !field) return;
          const row = state.matrix.find(r => r.id === id);
          if (!row) return;
          if (field === 'price') {
            row.price = Math.max(0, Number(el.value) || 0);
          } else if (field === 'unitCost') {
            row.unitCost = Math.max(0, Number(el.value) || 0);
          } else if (field === 'pct') {
            const mi = Number(el.getAttribute('data-month'));
            const pct = Math.max(0, Number(el.value) || 0) / 100;
            if (Number.isInteger(mi) && mi >= 0 && mi < row.curve.length) {
              row.curve[mi] = pct;
            }
          }
          // If user edits curve while default mode, flip default off
          if (state.dates.useDefaultCurves) {
            $('#useDefaultCurves').checked = false;
            state.dates.useDefaultCurves = false;
          }
          recalc({ preserveCurves: true });
        });

        $('#btnResetCurves').addEventListener('click', () => {
          // rebuild curves fresh
          recalc({ preserveCurves: false });
        });

        $('#btnCopyCurve').addEventListener('click', () => {
          const fromId = $('#copyFrom').value;
          const toId = $('#copyTo').value;
          if (!fromId || !toId || fromId === toId) return;
          const from = state.matrix.find(r => r.id === fromId);
          const to = state.matrix.find(r => r.id === toId);
          if (!from || !to) return;
          to.curve = from.curve.slice();
          $('#useDefaultCurves').checked = false;
          state.dates.useDefaultCurves = false;
          recalc({ preserveCurves: true });
        });

        // Save/load/reset/export
        $('#btnSave').addEventListener('click', () => {
          localStorage.setItem('phy_sales_forecast_state_v1', JSON.stringify(state));
          toast('Saved.');
        });
        $('#btnLoad').addEventListener('click', () => {
          const raw = localStorage.getItem('phy_sales_forecast_state_v1');
          if (!raw) return toast('No saved state found.');
          try {
            state = JSON.parse(raw);
            hydrateControls();
            recalc({ preserveCurves: true });
            toast('Loaded.');
          } catch (e) {
            console.error(e);
            toast('Could not load saved state.');
          }
        });
        $('#btnReset').addEventListener('click', () => {
          localStorage.removeItem('phy_sales_forecast_state_v1');
          location.reload();
        });

        $('#btnExportXlsx').addEventListener('click', exportXlsx);
      }

      function hydrateControls() {
        $('#mechRate').value = state.global.mechanicalStatRate ?? 1.15;
        $('#lacquerCosts').value = state.global.lacquerCosts ?? 0;
        $('#metalworkCosts').value = state.global.metalworkCosts ?? 0;
        $('#platingCosts').value = state.global.platingCosts ?? 0;
        $('#otherSetupCosts').value = state.global.otherSetupCosts ?? 0;

        $('#announceDate').value = state.dates.announceDate;
        $('#streetDate').value = state.dates.streetDate;
        $('#horizonMonths').value = state.dates.horizonMonths ?? 12;
        $('#sellThroughTarget').value = state.dates.sellThroughTargetPct ?? 100;
        $('#useDefaultCurves').checked = !!state.dates.useDefaultCurves;
      }

      function exportXlsx() {
        const { buckets, streetIndex } = getBuckets();
        // Ensure matrix is aligned
        buildMatrix(true);
        const fin = computeFinancials(buckets, streetIndex);

        const wb = XLSX.utils.book_new();

        // Sheet: Manufacturing
        const mfgRows = state.mfg.map((p, i) => ({
          Format: p.format,
          Variant: p.variant,
          "Mfg Qty": Number(p.qty) || 0,
          "Unit Cost": Number(p.cost) || 0,
          "Total Cost": (Number(p.qty) || 0) * (Number(p.cost) || 0),
        }));
        XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(mfgRows), "Production");

        // Sheet: Allocation
        const allocRows = state.mfg.map((p, i) => {
          const a = state.alloc[i] || {};
          const sum = CHANNELS.reduce((s, c) => s + (Number(a[c.key]) || 0), 0);
          return {
            Product: productLabel(i),
            "Mfg Qty": Number(p.qty) || 0,
            SRP: Number(a.srp) || 0,
            PPD: Number(a.ppd) || 0,
            Unallocated: (Number(p.qty) || 0) - sum,
            ...Object.fromEntries(CHANNELS.map(c => [c.name, Number(a[c.key]) || 0]))
          };
        });
        XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(allocRows), "Allocation");

        // Sheet: Monthly Revenue
        const monthly = buckets.map((b, i) => ({
          Month: b.label,
          "Units Sold": fin.monthUnits[i],
          "Revenue": fin.monthRevenue[i],
          "Cumulative KPI": fin.cumKpi[i]
        }));
        XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(monthly), "Monthly Summary");

        // Sheet: Curves (matrix)
        const curveRows = state.matrix.map(r => {
          const base = {
            Row: r.label,
            Alloc: r.allocUnits,
            Price: r.price,
            Cost: r.unitCost,
            "Sum %": r.curve.reduce((a, b) => a + b, 0)
          };
          buckets.forEach((b, i) => { base[b.label] = r.curve[i]; });
          return base;
        });
        XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(curveRows), "Curves");

        const name = `Physical_Sales_Forecast_${new Date().toISOString().slice(0, 10)}.xlsx`;
        XLSX.writeFile(wb, name);
      }

      // Simple toast
      function toast(msg) {
        const el = document.createElement('div');
        el.textContent = msg;
        el.style.position = 'fixed';
        el.style.bottom = '16px';
        el.style.left = '50%';
        el.style.transform = 'translateX(-50%)';
        el.style.padding = '10px 12px';
        el.style.borderRadius = '12px';
        el.style.background = 'rgba(2,6,23,.92)';
        el.style.border = '1px solid rgba(255,255,255,.10)';
        el.style.color = 'white';
        el.style.zIndex = 9999;
        el.style.fontSize = '12px';
        document.body.appendChild(el);
        setTimeout(() => { el.style.opacity = '0'; el.style.transition = 'opacity .25s'; }, 1200);
        setTimeout(() => { el.remove(); }, 1600);
      }

      // -------------------------
      // Init
      // -------------------------
      function init() {
        defaultDatesInit();
        ensureAllocLength();
        // Hydrate controls from state
        $('#mechRate').value = state.global.mechanicalStatRate;
        $('#lacquerCosts').value = state.global.lacquerCosts;
        $('#metalworkCosts').value = state.global.metalworkCosts;
        $('#platingCosts').value = state.global.platingCosts;
        $('#otherSetupCosts').value = state.global.otherSetupCosts;

        $('#announceDate').value = state.dates.announceDate;
        $('#streetDate').value = state.dates.streetDate;
        $('#horizonMonths').value = state.dates.horizonMonths;
        $('#sellThroughTarget').value = state.dates.sellThroughTargetPct;
        $('#useDefaultCurves').checked = state.dates.useDefaultCurves;

        wire();
        recalc({ preserveCurves: false });
      }

      init();
    })();
  </script>
</body>

</html>